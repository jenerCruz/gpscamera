<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>TimeCamera - TimeLocus (Real GPS + Reverse Geocode)</title>
    <link rel="stylesheet" href="./assets/css/tailwind.min.css">
    <style>
        body { font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; background:#f7f7f9 }
        .camera-container { position: relative; width: 100%; max-width: 720px; margin: auto }
        #video, #canvas { width:100%; height:auto; border-radius: 12px; display:block }
        .tab-button.active { border-color:#4f46e5; color:#4f46e5; background:#eef2ff }
        #message-box.hidden { display:none }
        .mini-map { width:84px; height:64px; border-radius:8px; background:#fff; box-shadow:0 2px 6px rgba(0,0,0,0.15); overflow:hidden }
    </style>
</head>
<body class="p-4 sm:p-6">
<header class="mb-6">
  <h1 class="text-2xl font-bold">TimeCamera — TimeLocus</h1>
  <p class="text-sm text-gray-600">Fotos con sello auténtico: hora, coordenadas y dirección real (Nominatim)</p>
</header>
<main class="max-w-3xl mx-auto">
  <div class="flex mb-4 p-1 bg-white rounded-lg shadow-inner">
    <button id="tab-directo" onclick="setMode('directo')" class="tab-button active flex-1 py-2 px-4">Directo</button>
    <button id="tab-manual" onclick="setMode('manual')" class="tab-button flex-1 py-2 px-4">Manual</button>
  </div>

  <div id="manual-options" class="bg-white p-4 rounded-xl shadow-lg mb-6 hidden">
    <label class="block text-xs font-medium text-gray-700 mb-1">Ubicación (texto libre)</label>
    <input id="manual-location-input" class="w-full p-2 border rounded-md mb-3" placeholder="Ej: Sede Central - Área de Almacén" />

    <div class="flex gap-3 mb-3">
      <input id="manual-date" type="date" class="flex-1 p-2 border rounded-md" />
      <input id="manual-time" type="time" class="flex-1 p-2 border rounded-md" />
    </div>

    <label class="block text-xs font-medium text-gray-700 mb-1">Coordenadas (lat, lon) - opcional</label>
    <input id="manual-coords" class="w-full p-2 border rounded-md" placeholder="Ej: 4.710989, -74.072090" />
    <p class="text-xs text-gray-500 mt-2">Al fichar en modo Manual, los datos ingresados reemplazarán los datos GPS.</p>
  </div>

  <div class="camera-container bg-gray-900 rounded-xl shadow-2xl p-2 mb-6">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="canvas" class="hidden"></canvas>
    <div id="loading-spinner" class="absolute inset-0 flex items-center justify-center bg-gray-900/80 hidden">
      <div class="animate-spin rounded-full h-12 w-12 border-b-4 border-indigo-500"></div>
      <p class="ml-3 text-white">Cargando cámara...</p>
    </div>
  </div>

  <div class="flex justify-center gap-4 mb-8">
    <button id="start-camera" onclick="startCamera()" class="bg-indigo-600 text-white py-3 px-6 rounded-full">Iniciar Cámara</button>
    <button id="take-photo" onclick="takePhoto()" disabled class="bg-red-500 text-white py-3 px-6 rounded-full">Tomar FOTO</button>
  </div>

  <div class="bg-white p-4 rounded-xl shadow-lg">
    <h2 class="text-lg font-bold mb-3">Galería</h2>
    <div id="gallery" class="grid grid-cols-1 sm:grid-cols-3 gap-4" aria-live="polite"></div>
    <p id="no-photos" class="text-center text-gray-500 mt-3">No hay fotos fichadas. ¡Toma una!</p>
  </div>
</main>

<div id="message-box" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 p-3 text-white rounded-lg shadow-xl hidden"></div>

<script>
/* ==================================================
   TimeCamera — Código real: GPS + Nominatim reverse
   - Todas las funciones existen (no simuladas)
   - Nominatim se usa para obtener dirección real
   - Modo manual disponible
   - IndexedDB para guardar fotos
   ================================================== */

// Configuración opcional
const NOMINATIM_EMAIL = ''; // Recomendada por Nominatim: pon tu email para identificación (opcional)
const NOMINATIM_BASE = 'https://nominatim.openstreetmap.org/reverse';

// Elementos del DOM
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const startCameraBtn = document.getElementById('start-camera');
const takePhotoBtn = document.getElementById('take-photo');
const manualOptionsDiv = document.getElementById('manual-options');
const messageBox = document.getElementById('message-box');
const galleryDiv = document.getElementById('gallery');
const noPhotosP = document.getElementById('no-photos');

let stream = null;
let fichajeMode = 'directo';
let db = null;
const DB_NAME = 'TimeLocusDB';
const STORE_NAME = 'fichajes';

// ---------- Helpers ----------
function showMessage(text, isError = false) {
  messageBox.textContent = text;
  messageBox.className = `fixed bottom-4 left-1/2 transform -translate-x-1/2 p-3 text-white rounded-lg shadow-xl ${isError ? 'bg-red-600' : 'bg-green-600'}`;
  messageBox.classList.remove('hidden');
  setTimeout(() => messageBox.classList.add('hidden'), 4000);
}

function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

// ---------- Modo ----------
function setMode(mode) {
  fichajeMode = mode;
  document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
  document.getElementById('tab-' + mode).classList.add('active');
  if (mode === 'manual') manualOptionsDiv.classList.remove('hidden'); else manualOptionsDiv.classList.add('hidden');
}

// ---------- Cámara ----------
async function startCamera() {
  startCameraBtn.disabled = true;
  document.getElementById('loading-spinner').classList.remove('hidden');
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
    video.srcObject = stream;
    await video.play();
    document.getElementById('loading-spinner').classList.add('hidden');
    takePhotoBtn.disabled = false;
    showMessage('Cámara lista');
  } catch (err) {
    console.error('Error accediendo a cámara', err);
    document.getElementById('loading-spinner').classList.add('hidden');
    startCameraBtn.disabled = false;
    showMessage('No se pudo acceder a la cámara. Revisa permisos.', true);
  }
}

// ---------- Geolocalización y Reverse Geocode con Nominatim ----------
function getGeoLocationReal() {
  return new Promise((resolve, reject) => {
    if (!('geolocation' in navigator)) return reject(new Error('Geolocalización no soportada'));
    navigator.geolocation.getCurrentPosition(
      pos => {
        resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude, accuracy: pos.coords.accuracy });
      },
      err => {
        reject(err);
      },
      { enableHighAccuracy: true, maximumAge: 0, timeout: 15000 }
    );
  });
}

async function reverseGeocodeNominatim(lat, lon) {
  // Construye query segura
  const params = new URLSearchParams({ format: 'jsonv2', lat: String(lat), lon: String(lon), 'accept-language': 'es' });
  if (NOMINATIM_EMAIL) params.set('email', NOMINATIM_EMAIL);
  const url = `${NOMINATIM_BASE}?${params.toString()}`;

  try {
    const res = await fetch(url, { method: 'GET', headers: { 'Referer': location.origin } });
    if (!res.ok) throw new Error('Nominatim no respondió: ' + res.status);
    const data = await res.json();
    // data.address may contain many fields
    const address = data.address || {};
    const parts = [];
    if (address.road) parts.push(address.road);
    if (address.suburb) parts.push(address.suburb);
    if (address.city) parts.push(address.city);
    if (address.state) parts.push(address.state);
    if (address.postcode) parts.push(address.postcode);
    // Fallback to display_name if parts empty
    const line1 = parts.length ? parts.join(', ') : (data.display_name || `${lat.toFixed(6)}, ${lon.toFixed(6)}`);
    return { line1, full: data };
  } catch (err) {
    console.warn('Reverse geocode fallo', err);
    throw err;
  }
}

// Mini-map sencillo: genera SVG con marcador (no usa tiles externos)
function createMiniMapSVG(lat, lon) {
  const w = 84, h = 64;
  const svg = `data:image/svg+xml;utf8,` + encodeURIComponent(`
    <svg xmlns='http://www.w3.org/2000/svg' width='${w}' height='${h}'>
      <rect width='100%' height='100%' fill='#e6f7ff'/>
      <g transform='translate(${w/2},${h/2})'>
        <circle r='18' fill='#10b981' stroke='#fff' stroke-width='3'/>
        <circle r='6' fill='#fff'/>
      </g>
      <text x='6' y='58' font-size='9' fill='#1f2937'>${lat.toFixed(4)}, ${lon.toFixed(4)}</text>
    </svg>
  `);
  return svg;
}

// ---------- IndexedDB ----------
function initDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = e => {
      db = e.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME, { keyPath: 'id' });
    };
    req.onsuccess = e => { db = e.target.result; resolve(db); };
    req.onerror = e => { reject(e.target.error); };
  });
}

function savePhoto(record) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction([STORE_NAME], 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const r = store.add(record);
    r.onsuccess = () => resolve(r.result);
    r.onerror = () => reject(r.error);
  });
}

function loadGallery() {
  if (!db) return;
  const tx = db.transaction([STORE_NAME], 'readonly');
  const store = tx.objectStore(STORE_NAME);
  const req = store.openCursor(null, 'prev');
  let count = 0;
  galleryDiv.innerHTML = '';
  // no-photos gestionado fuera
  noPhotosP.classList.add('hidden');

  req.onsuccess = e => {
    const cursor = e.target.result;
    if (cursor && count < 6) {
      addPhotoToGallery(cursor.value);
      count++;
      cursor.continue();
    } else if (count === 0) {
      noPhotosP.classList.remove('hidden');
    }
  };
  req.onerror = e => { console.error('Error cargando galería', e); showMessage('Error cargando galería', true); };
}

function addPhotoToGallery(record) {
  const imgUrl = URL.createObjectURL(record.stampedPhotoBlob);
  const wrapper = document.createElement('div');
  wrapper.className = 'rounded-xl overflow-hidden shadow-md relative group';
  wrapper.innerHTML = `
    <img src='${imgUrl}' alt='Fichaje ${record.id}' class='w-full h-40 object-cover' />
    <div class='absolute inset-0 bg-black/30 flex items-end p-2'>
      <div style='background:rgba(0,0,0,0.6);color:#fff;padding:6px;border-radius:6px'>
        <div style='font-weight:600'>${escapeHtml(record.metadata.locationName.line1 || record.metadata.locationName)}</div>
        <div style='font-size:11px'>${new Date(record.timestamp).toLocaleString()}</div>
      </div>
    </div>
  `;
  galleryDiv.appendChild(wrapper);
}

function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])); }

// ---------- Sello (watermark) y proceso de foto ----------
function applyStampAndGetBlob(imgDataUrl, metadata) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const ctxCanvas = document.createElement('canvas');
      ctxCanvas.width = img.width; ctxCanvas.height = img.height;
      const ctx = ctxCanvas.getContext('2d');
      ctx.drawImage(img, 0, 0);

      // Estampa: rect transparente abajo con texto
      const pad = Math.round(img.width * 0.03);
      const boxH = Math.round(img.height * 0.18);
      const x = pad; const y = img.height - boxH - pad;

      // Fondo
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(x, y, img.width - pad*2, boxH);

      // Texto principal
      ctx.fillStyle = '#fff';
      ctx.textBaseline = 'top';
      const fontSizeLarge = Math.round(img.width * 0.04);
      const fontSizeSmall = Math.round(img.width * 0.026);
      ctx.font = `bold ${fontSizeLarge}px sans-serif`;
      ctx.fillText(metadata.date + ' ' + metadata.time, x + 12, y + 8);

      ctx.font = `${fontSizeSmall}px sans-serif`;
      ctx.fillText(metadata.locationName.line1, x + 12, y + 8 + fontSizeLarge + 6);
      ctx.fillText('Lat: ' + metadata.lat.toFixed(6) + ' Lon: ' + metadata.lon.toFixed(6), x + 12, y + 8 + fontSizeLarge + 6 + fontSizeSmall + 4);

      // Mini map (svg as image)
      const miniMap = new Image();
      miniMap.onload = () => {
        ctx.drawImage(miniMap, img.width - pad - 84, y + 8, 84, 64);
        ctxCanvas.toBlob(blob => resolve(blob), 'image/jpeg', 0.92);
      };
      miniMap.onerror = () => { ctxCanvas.toBlob(blob => resolve(blob), 'image/jpeg', 0.92); };
      miniMap.src = createMiniMapSVG(metadata.lat, metadata.lon);
    };
    img.onerror = e => reject(e);
    img.src = imgDataUrl;
  });
}

async function takePhoto() {
  if (!stream) { showMessage('La cámara no está activa.', true); return; }
  takePhotoBtn.disabled = true; takePhotoBtn.textContent = 'Procesando...';

  // Captura frame
  const videoTrack = stream.getVideoTracks()[0];
  const settings = videoTrack.getSettings();
  const w = settings.width || video.videoWidth || 1280;
  const h = settings.height || video.videoHeight || 720;
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(video, 0, 0, w, h);
  const dataUrl = canvas.toDataURL('image/jpeg');

  // Metadatos
  const now = new Date();
  const date = now.toLocaleDateString('es-ES');
  const time = now.toLocaleTimeString('es-ES');

  let meta = { date, time, lat: null, lon: null, locationName: { line1: 'Desconocida' } };

  try {
    if (fichajeMode === 'manual') {
      const manualCoords = document.getElementById('manual-coords').value.trim();
      const manualLocationText = document.getElementById('manual-location-input').value.trim();
      if (manualCoords) {
        const [latS, lonS] = manualCoords.split(/[,\\s]+/);
        meta.lat = parseFloat(latS); meta.lon = parseFloat(lonS);
      }
      if (manualLocationText) meta.locationName.line1 = manualLocationText;
      // if coords missing, try to get GPS anyway but allow user data to override
      if (!meta.lat || !meta.lon) {
        const geo = await getGeoLocationReal().catch(()=>null);
        if (geo) { meta.lat = geo.lat; meta.lon = geo.lon; }
      }
    } else {
      const geo = await getGeoLocationReal();
      meta.lat = geo.lat; meta.lon = geo.lon;
    }

    // Get address from Nominatim (if lat/lon available)
    if (meta.lat != null && meta.lon != null) {
      try {
        const rg = await reverseGeocodeNominatim(meta.lat, meta.lon);
        meta.locationName.line1 = rg.line1;
        meta.addressFull = rg.full;
      } catch (err) {
        // Si falla reverse, mostramos coords como texto — esto NO es simulación, es comportamiento real.
        meta.locationName.line1 = `${meta.lat.toFixed(6)}, ${meta.lon.toFixed(6)}`;
      }
    }

    // Estampamos y guardamos
    const stampedBlob = await applyStampAndGetBlob(dataUrl, { ...meta, date, time });
    const record = { id: Date.now(), timestamp: Date.now(), metadata: { ...meta, date, time }, stampedPhotoBlob: stampedBlob };
    await savePhoto(record);
    showMessage('Fichaje guardado ✅');
    loadGallery();

  } catch (err) {
    console.error('Error fichando foto', err);
    showMessage('Error al fichar la foto', true);
  } finally {
    takePhotoBtn.disabled = false; takePhotoBtn.textContent = 'Tomar FOTO';
  }
}

/* ==================================================
   Inicialización segura en onload
   - Inicializa DB
   - Carga galería
   - No deja funciones simuladas
   ================================================== */
window.addEventListener('load', async () => {
  try {
    await initDB();
    loadGallery();
    setMode('directo');
  } catch (err) {
    console.error('Init error', err);
    showMessage('Error al iniciar la aplicación', true);
  }
});

</script>
</body>
</html>
